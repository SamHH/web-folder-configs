{-|
This module exposes a way to load the colorscheme at runtime as opposed to
compile-time for the purposes of (meaningful) compatibility with (py)wal.
-}

module Color (Palette (..), HexColor, getPalette, getColorOrHideous, hideous) where

import           Control.Exception              (catch)
import           Data.Aeson                     (FromJSON, decode)
import           System.Environment.XDG.BaseDir (getUserCacheFile)

type HexColor = String

newtype Theme = Theme
  { palette :: Palette
  }
  deriving (Generic, FromJSON)

data Palette = Palette
  { color0  :: HexColor
  , color1  :: HexColor
  , color2  :: HexColor
  , color3  :: HexColor
  , color4  :: HexColor
  , color5  :: HexColor
  , color6  :: HexColor
  , color7  :: HexColor
  , color8  :: HexColor
  , color9  :: HexColor
  , color10 :: HexColor
  , color11 :: HexColor
  , color12 :: HexColor
  , color13 :: HexColor
  , color14 :: HexColor
  , color15 :: HexColor
  }
  deriving (Generic, FromJSON)

-- From: https://hackage.haskell.org/package/ghc-8.10.2/docs/Maybes.html#v:tryMaybeT
tryMaybeT :: IO a -> MaybeT IO a
tryMaybeT f = MaybeT $ catch (Just <$> f) handler
  where handler (SomeException _) = pure Nothing

safeReadFileLBS :: FilePath -> MaybeT IO LByteString
safeReadFileLBS = tryMaybeT . readFileLBS

getThemePath :: MaybeT IO FilePath
getThemePath = tryMaybeT $ getUserCacheFile "wal" "colors.json"

-- | Attempts to get the colorscheme generated by (py)wal.
getPalette :: IO (Maybe Palette)
getPalette = fmap palette . (decode =<<) <$> runMaybeT (safeReadFileLBS =<< getThemePath)

getColorOrHideous :: Maybe Palette -> (Palette -> HexColor) -> HexColor
getColorOrHideous = flip $ maybe hideous

-- | A hideous color that can be used as a fallback to make failure obvious
-- without bringing the system down.
hideous :: HexColor
hideous = "#00FF00"
